

Developing Toscawidgets
=======================

Widgets are Stateless
---------------------

Role of data in your widget
---------------------------

Parameters
----------

Generic Functions
-------------------

Typical Widget Components
-------------------------

 * Template code
 * Resources
 * Server-side code

Template Code
~~~~~~~~~~~~~
 * TW supports all the template engines supported by `Buffet <http://projects.dowski.com/projects/buffet>`_
 * Templates are usually kept in separate files, although it is possible to inline in code.
 * The variables available in the template are: parameters defined for the widget (see below); TW built-in functions (args_for, value_for, display_child, css_class) and any provided by the user-defined functions update_params and get_extra_vars.

Resources
~~~~~~~~~
 * Once a resource is defined, the TW middleware serves that as a static directory.
 * Widgets specify their JS and CSS dependencies, and links are automatically inserted into appropriate points in the document (e.g. the HEAD section). There are two mechanisms for doing this:

  * Widgets are detected in variables passed from the controller to templates, and the resource requirements are collected. The site-wide master template includes code to render the requirements appropriately.
  * There is an experimental mode to rewrite the output document with links; this avoids the widgets needing to be passed to the template.

Server-side code
~~~~~~~~~~~~~~~~
 * Defines widget parameters, and default values for parameters.
 * Can run code at hook points; the main one is update_params, called just before display.
 * Having the template code call Python functions is discouraged; such code is better included in update_params.

Compound Widgets
----------------

All ToscaWidgets are in fact compound widgets. This means that every widget can contain child widgets which get rendered at the same time as the parent widget, without explicit instruction to do so.  This gives ToscaWidgets the following functionality:

 * Parent / child relationships
 * Repeating widgets
 * Generation of compound IDs
 * Decoding nested dictionaries for values and parameters
 * Utility functions, e.g. ichildren_hidden

Compound IDs are generated by going through the tree from root to the node, joining all the names (and numbers for repeaters) into a globally unique name. The generated IDs need to match the validation schema.

A compound widget takes a dictionary as it's value, and passes individual values to child widgets. A similar system works for parameters, but you have to do .child_args. TBD: check this, it's been a while


Need to add:
 * section on params
 * section on update_params
 * section about the javascript callbacks
