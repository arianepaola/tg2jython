<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<title>SQLAlchemy 0.4 Documentation - module sqlalchemy.engine</title>
	
    
    <link rel="stylesheet" href="style.css"></link>
    <link rel="stylesheet" href="docs.css"></link>
    <link href="syntaxhighlight.css" rel="stylesheet" type="text/css"></link>
    <script src="scripts.js"></script>

    <link rel="stylesheet" href="docutil.css"></link>



</head>
<body>








<div id="topanchor"><a name="top">&nbsp;</a></div>


<h1>SQLAlchemy 0.4 Documentation</h1>

<div id="pagecontrol"><a href="index.html">Multiple Pages</a> | <a href="documentation.html">One Page</a></div>

<div class="versionheader">Version: 0.4.7p1   Last Updated: 07/31/08 11:09:56</div>












    <div class="topnav">

    
    <div class="navbanner">
        <a href="index.html" class="totoc">Table of Contents</a>
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>


            
            Next: <a href="sqlalchemy_engine_default.html">module sqlalchemy.engine.default</a>
    </div>

        <h2>module sqlalchemy.engine</h2>
    </div>

	
	
    <ul>
        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_modfunc">Module Functions</a></li>

	        <li>
                
    <ul>
        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_modfunc_create_engine">create_engine()</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_modfunc_engine_descriptors">engine_descriptors()</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_modfunc_engine_from_config">engine_from_config()</a></li>

    </ul>

	        </li>
        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_BufferedColumnResultProxy">class BufferedColumnResultProxy(ResultProxy)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_BufferedColumnRow">class BufferedColumnRow(RowProxy)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_BufferedRowResultProxy">class BufferedRowResultProxy(ResultProxy)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Compiled">class Compiled(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connectable">class Connectable(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connection">class Connection(Connectable)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_DefaultRunner">class DefaultRunner(SchemaVisitor)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Dialect">class Dialect(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Engine">class Engine(Connectable)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_ExecutionContext">class ExecutionContext(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_NestedTransaction">class NestedTransaction(Transaction)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_ResultProxy">class ResultProxy(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_RootTransaction">class RootTransaction(Transaction)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_RowProxy">class RowProxy(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_SchemaIterator">class SchemaIterator(SchemaVisitor)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Transaction">class Transaction(object)</a></li>

        
        <li><a style="" href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_TwoPhaseTransaction">class TwoPhaseTransaction(Transaction)</a></li>

    </ul>

	</div>



    

    
    
    <A name="docstrings_sqlalchemy.engine"></a>
    
    <div class="sectionL2">

    <h3>module sqlalchemy.engine</h3>
    
    
    <div class="darkcell"><p>SQL connections, SQL execution and high-level DB-API interface.</p>
<p>The engine package defines the basic components used to interface
DB-API modules with higher-level statement construction,
connection-management, execution and result contexts.  The primary
&quot;entry point&quot; class into this package is the Engine and it's public
constructor <tt class="docutils literal"><span class="pre">create_engine()</span></tt>.</p>
<p>This package includes:</p>
<dl class="docutils">
<dt>base.py</dt>
<dd>Defines interface classes and some implementation classes which
comprise the basic components used to interface between a DB-API,
constructed and plain-text statements, connections, transactions,
and results.</dd>
<dt>default.py</dt>
<dd>Contains default implementations of some of the components defined
in base.py.  All current database dialects use the classes in
default.py as base classes for their own database-specific
implementations.</dd>
<dt>strategies.py</dt>
<dd>The mechanics of constructing <tt class="docutils literal"><span class="pre">Engine</span></tt> objects are represented
here.  Defines the <tt class="docutils literal"><span class="pre">EngineStrategy</span></tt> class which represents how
to go from arguments specified to the <tt class="docutils literal"><span class="pre">create_engine()</span></tt>
function, to a fully constructed <tt class="docutils literal"><span class="pre">Engine</span></tt>, including
initialization of connection pooling, dialects, and specific
subclasses of <tt class="docutils literal"><span class="pre">Engine</span></tt>.</dd>
<dt>threadlocal.py</dt>
<dd>The <tt class="docutils literal"><span class="pre">TLEngine</span></tt> class is defined here, which is a subclass of
the generic <tt class="docutils literal"><span class="pre">Engine</span></tt> and tracks <tt class="docutils literal"><span class="pre">Connection</span></tt> and
<tt class="docutils literal"><span class="pre">Transaction</span></tt> objects against the identity of the current
thread.  This allows certain programming patterns based around
the concept of a &quot;thread-local connection&quot; to be possible.
The <tt class="docutils literal"><span class="pre">TLEngine</span></tt> is created by using the &quot;threadlocal&quot; engine
strategy in conjunction with the <tt class="docutils literal"><span class="pre">create_engine()</span></tt> function.</dd>
<dt>url.py</dt>
<dd>Defines the <tt class="docutils literal"><span class="pre">URL</span></tt> class which represents the individual
components of a string URL passed to <tt class="docutils literal"><span class="pre">create_engine()</span></tt>.  Also
defines a basic module-loading strategy for the dialect specifier
within a URL.</dd>
</dl>
</div>
    

        
    
    <A name="docstrings_sqlalchemy.engine_modfunc"></a>
    
    <div class="sectionL3">

    <h3>Module Functions</h3>
    
    
                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.engine_modfunc_create_engine"></a>
    <b>def create_engine(<i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a new Engine instance.</p>
<p>The standard method of specifying the engine is via URL as the
first positional argument, to indicate the appropriate database
dialect and connection arguments, with additional keyword
arguments sent as options to the dialect and resulting Engine.</p>
<p>The URL is a string in the form
<tt class="docutils literal"><span class="pre">dialect://user:password&#64;host/dbname[?key=value..]</span></tt>, where
<tt class="docutils literal"><span class="pre">dialect</span></tt> is a name such as <tt class="docutils literal"><span class="pre">mysql</span></tt>, <tt class="docutils literal"><span class="pre">oracle</span></tt>, <tt class="docutils literal"><span class="pre">postgres</span></tt>,
etc.  Alternatively, the URL can be an instance of
<tt class="docutils literal"><span class="pre">sqlalchemy.engine.url.URL</span></tt>.</p>
<p><cite>**kwargs</cite> represents options to be sent to the Engine itself as
well as the components of the Engine, including the Dialect, the
ConnectionProvider, and the Pool.  A list of common options is as
follows:</p>
<dl class="docutils">
<dt>poolclass</dt>
<dd>a subclass of <tt class="docutils literal"><span class="pre">sqlalchemy.pool.Pool</span></tt> which will be used to
instantiate a connection pool.</dd>
<dt>pool</dt>
<dd>an instance of <tt class="docutils literal"><span class="pre">sqlalchemy.pool.DBProxy</span></tt> or
<tt class="docutils literal"><span class="pre">sqlalchemy.pool.Pool</span></tt> to be used as the underlying source for
connections (DBProxy/Pool is described in the previous section).
This argument supercedes &quot;poolclass&quot;.</dd>
<dt>echo</dt>
<dd>defaults to False: if True, the Engine will log all statements
as well as a repr() of their parameter lists to the engines
logger, which defaults to <tt class="docutils literal"><span class="pre">sys.stdout</span></tt>.  A Engine instances'
<cite>echo</cite> data member can be modified at any time to turn logging
on and off.  If set to the string 'debug', result rows will be
printed to the standard output as well.</dd>
<dt>logger</dt>
<dd>defaults to None: a file-like object where logging output can be
sent, if <cite>echo</cite> is set to True.  This defaults to
<tt class="docutils literal"><span class="pre">sys.stdout</span></tt>.</dd>
<dt>encoding</dt>
<dd>defaults to 'utf-8': the encoding to be used when
encoding/decoding Unicode strings.</dd>
<dt>convert_unicode</dt>
<dd>defaults to False: true if unicode conversion should be applied
to all str types.</dd>
<dt>module</dt>
<dd>defaults to None: this is a reference to a DB-API 2.0 module to
be used instead of the dialect's default module.</dd>
<dt>strategy</dt>
<dd><p class="first">allows alternate Engine implementations to take effect.  Current
implementations include <tt class="docutils literal"><span class="pre">plain</span></tt> and <tt class="docutils literal"><span class="pre">threadlocal</span></tt>.  The
default used by this function is <tt class="docutils literal"><span class="pre">plain</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">plain</span></tt> provides support for a Connection object which can be
used to execute SQL queries with a specific underlying DB-API
connection.</p>
<p class="last"><tt class="docutils literal"><span class="pre">threadlocal</span></tt> is similar to <tt class="docutils literal"><span class="pre">plain</span></tt> except that it adds
support for a thread-local connection and transaction context,
which allows a group of engine operations to participate using
the same underlying connection and transaction without the need
for explicitly passing a single Connection.</p>
</dd>
</dl>

    </div>
    </div>

                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.engine_modfunc_engine_descriptors"></a>
    <b>def engine_descriptors(<i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Deprecated.
Provide a listing of all the database implementations supported.</p>
<blockquote>
This method will be removed in 0.5.</blockquote>

    </div>
    </div>

                
    <div class="darkcell">
    
    <A name="docstrings_sqlalchemy.engine_modfunc_engine_from_config"></a>
    <b>def engine_from_config(<i>configuration</i>, <i>prefix='sqlalchemy.'</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a new Engine instance using a configuration dictionary.</p>
<p>The dictionary is typically produced from a config file where keys
are prefixed, such as sqlalchemy.url, sqlalchemy.echo, etc.  The
'prefix' argument indicates the prefix to be searched for.</p>
<p>A select set of keyword arguments will be &quot;coerced&quot; to their
expected type based on string values.  In a future release, this
functionality will be expanded and include dialect-specific
arguments.</p>

    </div>
    </div>

        

    </div>




            
    

    
    
    <A name="docstrings_sqlalchemy.engine_BufferedColumnResultProxy"></a>
    
    <div class="sectionL3">

    <h3>class BufferedColumnResultProxy(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_ResultProxy">ResultProxy</a>)</h3>
    
    
    <div class="darkcell"><p>A ResultProxy with column buffering behavior.</p>
<p><tt class="docutils literal"><span class="pre">ResultProxy</span></tt> that loads all columns into memory each time
fetchone() is called.  If fetchmany() or fetchall() are called,
the full grid of results is fetched.  This is to operate with
databases where result rows contain &quot;live&quot; results that fall out
of scope unless explicitly fetched.  Currently this includes just
cx_Oracle LOB objects, but this behavior is known to exist in
other DB-APIs as well (Pygresql, currently unsupported).</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def fetchall(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def fetchmany(<i>self</i>, <i>size=None</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_BufferedColumnRow"></a>
    
    <div class="sectionL3">

    <h3>class BufferedColumnRow(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_RowProxy">RowProxy</a>)</h3>
    
    
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>parent</i>, <i>row</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">BufferedColumnRow</span></tt>.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_BufferedRowResultProxy"></a>
    
    <div class="sectionL3">

    <h3>class BufferedRowResultProxy(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_ResultProxy">ResultProxy</a>)</h3>
    
    
    <div class="darkcell"><p>A ResultProxy with row buffering behavior.</p>
<p><tt class="docutils literal"><span class="pre">ResultProxy</span></tt> that buffers the contents of a selection of rows
before <tt class="docutils literal"><span class="pre">fetchone()</span></tt> is called.  This is to allow the results of
<tt class="docutils literal"><span class="pre">cursor.description</span></tt> to be available immediately, when
interfacing with a DB-API that requires rows to be consumed before
this information is available (currently psycopg2, when used with
server-side cursors).</p>
<p>The pre-fetching behavior fetches only one row initially, and then
grows its buffer size by a fixed amount with each successive need
for additional rows up to a size of 100.</p>
</div>
    


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Compiled"></a>
    
    <div class="sectionL3">

    <h3>class Compiled(object)</h3>
    
    
    <div class="darkcell"><p>Represent a compiled SQL expression.</p>
<p>The <tt class="docutils literal"><span class="pre">__str__</span></tt> method of the <tt class="docutils literal"><span class="pre">Compiled</span></tt> object should produce
the actual text of the statement.  <tt class="docutils literal"><span class="pre">Compiled</span></tt> objects are
specific to their underlying database dialect, and also may
or may not be specific to the columns referenced within a
particular set of bind parameters.  In no case should the
<tt class="docutils literal"><span class="pre">Compiled</span></tt> object be dependent on the actual values of those
bind parameters, even though it may reference those values as
defaults.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>dialect</i>, <i>statement</i>, <i>column_keys=None</i>, <i>bind=None</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">Compiled</span></tt> object.</p>
<dl class="docutils">
<dt>dialect</dt>
<dd><tt class="docutils literal"><span class="pre">Dialect</span></tt> to compile against.</dd>
<dt>statement</dt>
<dd><tt class="docutils literal"><span class="pre">ClauseElement</span></tt> to be compiled.</dd>
<dt>column_keys</dt>
<dd>a list of column names to be compiled into an INSERT or UPDATE
statement.</dd>
<dt>bind</dt>
<dd>Optional Engine or Connection to compile this statement against.</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def compile(<i>self</i>)</b>
    <div class="docstring">
    <p>Produce the internal string representation of this element.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def construct_params(<i>self</i>, <i>params</i>)</b>
    <div class="docstring">
    <p>Return the bind params for this compiled object.</p>
<p><cite>params</cite> is a dict of string/object pairs whos
values will override bind values compiled in
to the statement.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    <p>Execute this compiled object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_params(<i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Deprecated.
Use construct_params().  (supports unicode names)</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    <p>Execute this compiled object and return the result's scalar value.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Connectable"></a>
    
    <div class="sectionL3">

    <h3>class Connectable(object)</h3>
    
    
    <div class="darkcell"><p>Interface for an object that can provide an Engine and a Connection object which correponds to that Engine.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def contextual_connect(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a Connection object which may be part of an ongoing context.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create(<i>self</i>, <i>entity</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a table or index given an appropriate schema object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def drop(<i>self</i>, <i>entity</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Drop a table or index given an appropriate schema object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>, <i>object</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute_clauseelement(<i>self</i>, <i>elem</i>, <i>multiparams=None</i>, <i>params=None</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Connection"></a>
    
    <div class="sectionL3">

    <h3>class Connection(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connectable">Connectable</a>)</h3>
    
    
    <div class="darkcell"><p>Provides high-level functionality for a wrapped DB-API connection.</p>
<p>Provides execution support for string-based SQL statements as well
as ClauseElement, Compiled and DefaultGenerator objects.  Provides
a begin method to return Transaction objects.</p>
<p>The Connection object is <strong>not</strong> threadsafe.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>engine</i>, <i>connection=None</i>, <i>close_with_result=False</i>, <i>_branch=False</i>)</b>
    <div class="docstring">
    <p>Construct a new Connection.</p>
<p>Connection objects are typically constructed by an
<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Engine">Engine</a>, see the <tt class="docutils literal"><span class="pre">connect()</span></tt> and
<tt class="docutils literal"><span class="pre">contextual_connect()</span></tt> methods of Engine.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def begin(<i>self</i>)</b>
    <div class="docstring">
    <p>Begin a transaction and return a Transaction handle.</p>
<p>Repeated calls to <tt class="docutils literal"><span class="pre">begin</span></tt> on the same Connection will create
a lightweight, emulated nested transaction.  Only the
outermost transaction may <tt class="docutils literal"><span class="pre">commit</span></tt>.  Calls to <tt class="docutils literal"><span class="pre">commit</span></tt> on
inner transactions are ignored.  Any transaction in the
hierarchy may <tt class="docutils literal"><span class="pre">rollback</span></tt>, however.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def begin_nested(<i>self</i>)</b>
    <div class="docstring">
    <p>Begin a nested transaction and return a Transaction handle.</p>
<p>Nested transactions require SAVEPOINT support in the
underlying database.  Any transaction in the hierarchy may
<tt class="docutils literal"><span class="pre">commit</span></tt> and <tt class="docutils literal"><span class="pre">rollback</span></tt>, however the outermost transaction
still controls the overall <tt class="docutils literal"><span class="pre">commit</span></tt> or <tt class="docutils literal"><span class="pre">rollback</span></tt> of the
transaction of a whole.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def begin_twophase(<i>self</i>, <i>xid=None</i>)</b>
    <div class="docstring">
    <p>Begin a two-phase or XA transaction and return a Transaction handle.</p>
<dl class="docutils">
<dt>xid</dt>
<dd>the two phase transaction id.  If not supplied, a random id
will be generated.</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close(<i>self</i>)</b>
    <div class="docstring">
    <p>Close this Connection.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>closed = property()</b>
         <div class="docstring">
         <p>return True if this connection is closed.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def commit_prepared(<i>self</i>, <i>xid</i>, <i>recover=False</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def connect(<i>self</i>)</b>
    <div class="docstring">
    <p>Returns self.</p>
<p>This <tt class="docutils literal"><span class="pre">Connectable</span></tt> interface method returns self, allowing
Connections to be used interchangably with Engines in most
situations that require a bind.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>connection = property()</b>
         <div class="docstring">
         <p>The underlying DB-API connection managed by this Connection.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def contextual_connect(<i>self</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Returns self.</p>
<p>This <tt class="docutils literal"><span class="pre">Connectable</span></tt> interface method returns self, allowing
Connections to be used interchangably with Engines in most
situations that require a bind.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create(<i>self</i>, <i>entity</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a Table or Index given an appropriate Schema object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def default_schema_name(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def detach(<i>self</i>)</b>
    <div class="docstring">
    <p>Detach the underlying DB-API connection from its connection pool.</p>
<p>This Connection instance will remain useable.  When closed,
the DB-API connection will be literally closed and not
returned to its pool.  The pool will typically lazily create a
new connection to replace the detached connection.</p>
<p>This method can be used to insulate the rest of an application
from a modified state on a connection (such as a transaction
isolation level or similar).  Also see
<a href="sqlalchemy_interfaces.html#docstrings_sqlalchemy.interfaces_PoolListener">PoolListener</a> for a mechanism to modify
connection state when connections leave and return to their
connection pool.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>dialect = property()</b>
         <div class="docstring">
         <p>Dialect used by this Connection.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def drop(<i>self</i>, <i>entity</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Drop a Table or Index given an appropriate Schema object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>, <i>object</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    <p>Executes and returns a ResultProxy.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute_clauseelement(<i>self</i>, <i>elem</i>, <i>multiparams=None</i>, <i>params=None</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def in_transaction(<i>self</i>)</b>
    <div class="docstring">
    <p>Return True if a transaction is in progress.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>info = property()</b>
         <div class="docstring">
         <p>A collection of per-DB-API connection instance properties.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def invalidate(<i>self</i>, <i>exception=None</i>)</b>
    <div class="docstring">
    <p>Invalidate the underlying DBAPI connection associated with this Connection.</p>
<p>The underlying DB-API connection is literally closed (if
possible), and is discarded.  Its source connection pool will
typically lazily create a new connection to replace it.</p>
<p>Upon the next usage, this Connection will attempt to reconnect
to the pool with a new connection.</p>
<p>Transactions in progress remain in an &quot;opened&quot; state (even though
the actual transaction is gone); these must be explicitly
rolled back before a reconnect on this Connection can proceed.  This
is to prevent applications from accidentally continuing their transactional
operations in a non-transactional state.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>invalidated = property()</b>
         <div class="docstring">
         <p>return True if this connection was invalidated.</p>

         </div> 
         </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>properties = property()</b>
         <div class="docstring">
         <p>An alias for the .info collection, will be removed in 0.5.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def recover_twophase(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def reflecttable(<i>self</i>, <i>table</i>, <i>include_columns=None</i>)</b>
    <div class="docstring">
    <p>Reflect the columns in the given string table name from the database.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def rollback_prepared(<i>self</i>, <i>xid</i>, <i>recover=False</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def run_callable(<i>self</i>, <i>callable_</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>, <i>object</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    <p>Executes and returns the first column of the first row.</p>
<p>The underlying result/cursor is closed after execution.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>should_close_with_result = property()</b>
         <div class="docstring">
         <p>Indicates if this Connection should be closed when a corresponding
ResultProxy is closed; this is essentially an auto-release mode.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def statement_compiler(<i>self</i>, <i>statement</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_DefaultRunner"></a>
    
    <div class="sectionL3">

    <h3>class DefaultRunner(<a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_SchemaVisitor">SchemaVisitor</a>)</h3>
    
    
    <div class="darkcell"><p>A visitor which accepts ColumnDefault objects, produces the
dialect-specific SQL corresponding to their execution, and
executes the SQL, returning the result value.</p>
<p>DefaultRunners are used internally by Engines and Dialects.
Specific database modules should provide their own subclasses of
DefaultRunner to allow database-specific behavior.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>context</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">DefaultRunner</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def exec_default_sql(<i>self</i>, <i>default</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute_string(<i>self</i>, <i>stmt</i>, <i>params=None</i>)</b>
    <div class="docstring">
    <p>execute a string statement, using the raw cursor,
and return a scalar result.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_column_default(<i>self</i>, <i>column</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_column_onupdate(<i>self</i>, <i>column</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def visit_column_default(<i>self</i>, <i>default</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def visit_column_onupdate(<i>self</i>, <i>onupdate</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def visit_passive_default(<i>self</i>, <i>default</i>)</b>
    <div class="docstring">
    <p>Do nothing.</p>
<p>Passive defaults by definition return None on the app side,
and are post-fetched to get the DB-side value.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def visit_sequence(<i>self</i>, <i>seq</i>)</b>
    <div class="docstring">
    <p>Do nothing.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Dialect"></a>
    
    <div class="sectionL3">

    <h3>class Dialect(object)</h3>
    
    
    <div class="darkcell"><p>Define the behavior of a specific database and DB-API combination.</p>
<p>Any aspect of metadata definition, SQL query generation,
execution, result-set handling, or anything else which varies
between databases is defined under the general category of the
Dialect.  The Dialect acts as a factory for other
database-specific object implementations including
ExecutionContext, Compiled, DefaultGenerator, and TypeEngine.</p>
<p>All Dialects implement the following attributes:</p>
<dl class="docutils">
<dt>positional</dt>
<dd>True if the paramstyle for this Dialect is positional.</dd>
<dt>paramstyle</dt>
<dd>the paramstyle to be used (some DB-APIs support multiple
paramstyles).</dd>
<dt>convert_unicode</dt>
<dd>True if Unicode conversion should be applied to all <tt class="docutils literal"><span class="pre">str</span></tt>
types.</dd>
<dt>encoding</dt>
<dd>type of encoding to use for unicode, usually defaults to
'utf-8'.</dd>
<dt>schemagenerator</dt>
<dd>a <a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_SchemaVisitor">SchemaVisitor</a> class which generates
schemas.</dd>
<dt>schemadropper</dt>
<dd>a <a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_SchemaVisitor">SchemaVisitor</a> class which drops schemas.</dd>
<dt>defaultrunner</dt>
<dd>a <a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_SchemaVisitor">SchemaVisitor</a> class which executes
defaults.</dd>
<dt>statement_compiler</dt>
<dd>a <b>Compiled</b> class used to compile SQL
statements</dd>
<dt>preparer</dt>
<dd>a <a href="sqlalchemy_sql_compiler.html#docstrings_sqlalchemy.sql.compiler_IdentifierPreparer">IdentifierPreparer</a> class used to
quote identifiers.</dd>
<dt>supports_alter</dt>
<dd><tt class="docutils literal"><span class="pre">True</span></tt> if the database supports <tt class="docutils literal"><span class="pre">ALTER</span> <span class="pre">TABLE</span></tt>.</dd>
<dt>max_identifier_length</dt>
<dd>The maximum length of identifier names.</dd>
<dt>supports_unicode_statements</dt>
<dd>Indicate whether the DB-API can receive SQL statements as Python unicode strings</dd>
<dt>supports_sane_rowcount</dt>
<dd>Indicate whether the dialect properly implements rowcount for <tt class="docutils literal"><span class="pre">UPDATE</span></tt> and <tt class="docutils literal"><span class="pre">DELETE</span></tt> statements.</dd>
<dt>supports_sane_multi_rowcount</dt>
<dd>Indicate whether the dialect properly implements rowcount for <tt class="docutils literal"><span class="pre">UPDATE</span></tt> and <tt class="docutils literal"><span class="pre">DELETE</span></tt> statements
when executed via executemany.</dd>
<dt>preexecute_pk_sequences</dt>
<dd>Indicate if the dialect should pre-execute sequences on primary key
columns during an INSERT, if it's desired that the new row's primary key
be available after execution.</dd>
<dt>supports_pk_autoincrement</dt>
<dd>Indicates if the dialect should allow the database to passively assign
a primary key column value.</dd>
<dt>dbapi_type_map</dt>
<dd><p class="first">A mapping of DB-API type objects present in this Dialect's
DB-API implmentation mapped to TypeEngine implementations used
by the dialect.</p>
<p class="last">This is used to apply types to result sets based on the DB-API
types present in cursor.description; it only takes effect for
result sets against textual statements where no explicit
typemap was present.</p>
</dd>
</dl>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create_connect_args(<i>self</i>, <i>url</i>)</b>
    <div class="docstring">
    <p>Build DB-API compatible connection arguments.</p>
<p>Given a <a href="sqlalchemy_engine_url.html#docstrings_sqlalchemy.engine.url_URL">URL</a> object, returns a tuple
consisting of a <cite>*args</cite>/<cite>**kwargs</cite> suitable to send directly
to the dbapi's connect function.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create_execution_context(<i>self</i>, <i>connection</i>, <i>compiled=None</i>, <i>compiled_parameters=None</i>, <i>statement=None</i>, <i>parameters=None</i>)</b>
    <div class="docstring">
    <p>Return a new <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_ExecutionContext">ExecutionContext</a> object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create_xid(<i>self</i>)</b>
    <div class="docstring">
    <p>Create a two-phase transaction ID.</p>
<p>This id will be passed to do_begin_twophase(),
do_rollback_twophase(), do_commit_twophase().  Its format is
unspecified.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_begin(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Provide an implementation of <em>connection.begin()</em>, given a DB-API connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_begin_twophase(<i>self</i>, <i>connection</i>, <i>xid</i>)</b>
    <div class="docstring">
    <p>Begin a two phase transaction on the given connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_commit(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Provide an implementation of <em>connection.commit()</em>, given a DB-API connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_commit_twophase(<i>self</i>, <i>connection</i>, <i>xid</i>, <i>is_prepared=True</i>, <i>recover=False</i>)</b>
    <div class="docstring">
    <p>Commit a two phase transaction on the given connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_execute(<i>self</i>, <i>cursor</i>, <i>statement</i>, <i>parameters</i>, <i>context=None</i>)</b>
    <div class="docstring">
    <p>Provide an implementation of <em>cursor.execute(statement, parameters)</em>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_executemany(<i>self</i>, <i>cursor</i>, <i>statement</i>, <i>parameters</i>, <i>context=None</i>)</b>
    <div class="docstring">
    <p>Provide an implementation of <em>cursor.executemany(statement, parameters)</em>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_prepare_twophase(<i>self</i>, <i>connection</i>, <i>xid</i>)</b>
    <div class="docstring">
    <p>Prepare a two phase transaction on the given connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_recover_twophase(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Recover list of uncommited prepared two phase transaction identifiers on the given connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_release_savepoint(<i>self</i>, <i>connection</i>, <i>name</i>)</b>
    <div class="docstring">
    <p>Release the named savepoint on a SQL Alchemy connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_rollback(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Provide an implementation of <em>connection.rollback()</em>, given a DB-API connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_rollback_to_savepoint(<i>self</i>, <i>connection</i>, <i>name</i>)</b>
    <div class="docstring">
    <p>Rollback a SQL Alchemy connection to the named savepoint.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_rollback_twophase(<i>self</i>, <i>connection</i>, <i>xid</i>, <i>is_prepared=True</i>, <i>recover=False</i>)</b>
    <div class="docstring">
    <p>Rollback a two phase transaction on the given connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def do_savepoint(<i>self</i>, <i>connection</i>, <i>name</i>)</b>
    <div class="docstring">
    <p>Create a savepoint with the given name on a SQLAlchemy connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_default_schema_name(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Return the string name of the currently selected schema given a <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connection">Connection</a>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def has_sequence(<i>self</i>, <i>connection</i>, <i>sequence_name</i>)</b>
    <div class="docstring">
    <p>Check the existence of a particular sequence in the database.</p>
<p>Given a <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connection">Connection</a> object and a string
<cite>sequence_name</cite>, return True if the given sequence exists in
the database, False otherwise.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def has_table(<i>self</i>, <i>connection</i>, <i>table_name</i>, <i>schema=None</i>)</b>
    <div class="docstring">
    <p>Check the existence of a particular table in the database.</p>
<p>Given a <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connection">Connection</a> object and a string
<cite>table_name</cite>, return True if the given table (possibly within
the specified <cite>schema</cite>) exists in the database, False
otherwise.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def is_disconnect(<i>self</i>, <i>e</i>)</b>
    <div class="docstring">
    <p>Return True if the given DB-API error indicates an invalid connection</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def oid_column_name(<i>self</i>, <i>column</i>)</b>
    <div class="docstring">
    <p>Return the oid column name for this Dialect</p>
<p>May return <tt class="docutils literal"><span class="pre">None</span></tt> if the dialect can't o won't support
OID/ROWID features.</p>
<p>The <a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_Column">Column</a> instance which represents OID
for the query being compiled is passed, so that the dialect
can inspect the column and its parent selectable to determine
if OID/ROWID is not selected for a particular selectable
(i.e. Oracle doesnt support ROWID for UNION, GROUP BY,
DISTINCT, etc.)</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def reflecttable(<i>self</i>, <i>connection</i>, <i>table</i>, <i>include_columns=None</i>)</b>
    <div class="docstring">
    <p>Load table description from the database.</p>
<p>Given a <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connection">Connection</a> and a
<a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_Table">Table</a> object, reflect its columns and
properties from the database.  If include_columns (a list or
set) is specified, limit the autoload to the given column
names.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def server_version_info(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Return a tuple of the database's version number.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def type_descriptor(<i>self</i>, <i>typeobj</i>)</b>
    <div class="docstring">
    <p>Transform a generic type to a database-specific type.</p>
<p>Transforms the given <a href="sqlalchemy_types.html#docstrings_sqlalchemy.types_TypeEngine">TypeEngine</a> instance
from generic to database-specific.</p>
<p>Subclasses will usually use the
<b>adapt_type()</b> method in the types module to
make this job easy.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Engine"></a>
    
    <div class="sectionL3">

    <h3>class Engine(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Connectable">Connectable</a>)</h3>
    
    
    <div class="darkcell"><p>Connects a Pool, a Dialect and a CompilerFactory together to
provide a default implementation of SchemaEngine.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>pool</i>, <i>dialect</i>, <i>url</i>, <i>echo=None</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">Engine</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def connect(<i>self</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Return a newly allocated Connection object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def contextual_connect(<i>self</i>, <i>close_with_result=False</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Return a Connection object which may be newly allocated, or may be part of some ongoing context.</p>
<p>This Connection is meant to be used by the various &quot;auto-connecting&quot; operations.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create(<i>self</i>, <i>entity</i>, <i>connection=None</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Create a table or index within this engine's database connection given a schema.Table object.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def dispose(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def drop(<i>self</i>, <i>entity</i>, <i>connection=None</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Drop a table or index within this engine's database connection given a schema.Table object.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>echo = property()</b>
         <div class="docstring">
         <p>When <tt class="docutils literal"><span class="pre">True</span></tt>, enable log output for this element.</p>
<p>This has the effect of setting the Python logging level for the namespace
of this element's class and object reference.  A value of boolean <tt class="docutils literal"><span class="pre">True</span></tt>
indicates that the loglevel <tt class="docutils literal"><span class="pre">logging.INFO</span></tt> will be set for the logger,
whereas the string value <tt class="docutils literal"><span class="pre">debug</span></tt> will set the loglevel to
<tt class="docutils literal"><span class="pre">logging.DEBUG</span></tt>.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>, <i>statement</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute_clauseelement(<i>self</i>, <i>elem</i>, <i>multiparams=None</i>, <i>params=None</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>func = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def has_table(<i>self</i>, <i>table_name</i>, <i>schema=None</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>name = property()</b>
         <div class="docstring">
         <p>String name of the <a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Dialect">Dialect</a> in use by this <tt class="docutils literal"><span class="pre">Engine</span></tt>.</p>

         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def raw_connection(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a DB-API connection.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def reflecttable(<i>self</i>, <i>table</i>, <i>connection=None</i>, <i>include_columns=None</i>)</b>
    <div class="docstring">
    <p>Given a Table object, reflects its columns and properties from the database.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def run_callable(<i>self</i>, <i>callable_</i>, <i>connection=None</i>, <i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>, <i>statement</i>, <i>*multiparams</i>, <i>**params</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def statement_compiler(<i>self</i>, <i>statement</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def table_names(<i>self</i>, <i>schema=None</i>, <i>connection=None</i>)</b>
    <div class="docstring">
    <p>Return a list of all table names available in the database.</p>
<dl class="docutils">
<dt>schema:</dt>
<dd>Optional, retrieve names from a non-default schema.</dd>
<dt>connection:</dt>
<dd>Optional, use a specified connection.  Default is the
<tt class="docutils literal"><span class="pre">contextual_connect</span></tt> for this <tt class="docutils literal"><span class="pre">Engine</span></tt>.</dd>
</dl>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def text(<i>self</i>, <i>text</i>, <i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Return a sql.text() object for performing literal queries.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def transaction(<i>self</i>, <i>callable_</i>, <i>connection=None</i>, <i>*args</i>, <i>**kwargs</i>)</b>
    <div class="docstring">
    <p>Execute the given function within a transaction boundary.</p>
<p>This is a shortcut for explicitly calling <cite>begin()</cite> and <cite>commit()</cite>
and optionally <cite>rollback()</cite> when exceptions are raised.  The
given <cite>*args</cite> and <cite>**kwargs</cite> will be passed to the function, as
well as the Connection used in the transaction.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_ExecutionContext"></a>
    
    <div class="sectionL3">

    <h3>class ExecutionContext(object)</h3>
    
    
    <div class="darkcell"><p>A messenger object for a Dialect that corresponds to a single execution.</p>
<p>ExecutionContext should have these datamembers:</p>
<dl class="docutils">
<dt>connection</dt>
<dd>Connection object which can be freely used by default value
generators to execute SQL.  This Connection should reference the
same underlying connection/transactional resources of
root_connection.</dd>
<dt>root_connection</dt>
<dd>Connection object which is the source of this ExecutionContext.  This
Connection may have close_with_result=True set, in which case it can
only be used once.</dd>
<dt>dialect</dt>
<dd>dialect which created this ExecutionContext.</dd>
<dt>cursor</dt>
<dd>DB-API cursor procured from the connection,</dd>
<dt>compiled</dt>
<dd>if passed to constructor, sqlalchemy.engine.base.Compiled object
being executed,</dd>
<dt>statement</dt>
<dd>string version of the statement to be executed.  Is either
passed to the constructor, or must be created from the
sql.Compiled object by the time pre_exec() has completed.</dd>
<dt>parameters</dt>
<dd>bind parameters passed to the execute() method.  For compiled
statements, this is a dictionary or list of dictionaries.  For
textual statements, it should be in a format suitable for the
dialect's paramstyle (i.e. dict or list of dicts for non
positional, list or list of lists/tuples for positional).</dd>
<dt>isinsert</dt>
<dd>True if the statement is an INSERT.</dd>
<dt>isupdate</dt>
<dd>True if the statement is an UPDATE.</dd>
<dt>should_autocommit</dt>
<dd>True if the statement is a &quot;committable&quot; statement</dd>
<dt>returns_rows</dt>
<dd>True if the statement should return result rows</dd>
<dt>postfetch_cols</dt>
<dd>a list of Column objects for which a server-side default
or inline SQL expression value was fired off.  applies to inserts and updates.</dd>
</dl>
<p>The Dialect should provide an ExecutionContext via the
create_execution_context() method.  The <cite>pre_exec</cite> and <cite>post_exec</cite>
methods will be called for compiled statements.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def create_cursor(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a new cursor generated from this ExecutionContext's connection.</p>
<p>Some dialects may wish to change the behavior of
connection.cursor(), such as postgres which may return a PG
&quot;server side&quot; cursor.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def get_rowcount(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the count of rows updated/deleted for an UPDATE/DELETE statement.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_inserted_ids(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the list of the primary key values for the last insert statement executed.</p>
<p>This does not apply to straight textual clauses; only to
<tt class="docutils literal"><span class="pre">sql.Insert</span></tt> objects compiled against a <tt class="docutils literal"><span class="pre">schema.Table</span></tt>
object.  The order of items in the list is the same as that of
the Table's 'primary_key' attribute.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_inserted_params(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a dictionary of the full parameter dictionary for the last compiled INSERT statement.</p>
<p>Includes any ColumnDefaults or Sequences that were pre-executed.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_updated_params(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a dictionary of the full parameter dictionary for the last compiled UPDATE statement.</p>
<p>Includes any ColumnDefaults that were pre-executed.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def lastrow_has_defaults(<i>self</i>)</b>
    <div class="docstring">
    <p>Return True if the last INSERT or UPDATE row contained
inlined or database-side defaults.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def post_execution(<i>self</i>)</b>
    <div class="docstring">
    <p>Called after the execution of a compiled statement.</p>
<p>If a compiled statement was passed to this ExecutionContext,
the <cite>last_insert_ids</cite>, <cite>last_inserted_params</cite>, etc.
datamembers should be available after this method completes.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def pre_execution(<i>self</i>)</b>
    <div class="docstring">
    <p>Called before an execution of a compiled statement.</p>
<p>If a compiled statement was passed to this ExecutionContext,
the <cite>statement</cite> and <cite>parameters</cite> datamembers must be
initialized after this statement is complete.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def result(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a result object corresponding to this ExecutionContext.</p>
<p>Returns a ResultProxy.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def should_autocommit_compiled(<i>self</i>, <i>compiled</i>)</b>
    <div class="docstring">
    <p>return True if the given Compiled object refers to a &quot;committable&quot; statement.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def should_autocommit_text(<i>self</i>, <i>statement</i>)</b>
    <div class="docstring">
    <p>Parse the given textual statement and return True if it refers to a &quot;committable&quot; statement</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_NestedTransaction"></a>
    
    <div class="sectionL3">

    <h3>class NestedTransaction(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Transaction">Transaction</a>)</h3>
    
    
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>connection</i>, <i>parent</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">NestedTransaction</span></tt>.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_ResultProxy"></a>
    
    <div class="sectionL3">

    <h3>class ResultProxy(object)</h3>
    
    
    <div class="darkcell"><p>Wraps a DB-API cursor object to provide easier access to row columns.</p>
<p>Individual columns may be accessed by their integer position,
case-insensitive column name, or by <tt class="docutils literal"><span class="pre">schema.Column</span></tt>
object. e.g.:</p>
<pre class="literal-block">
row = fetchone()

col1 = row[0]    # access via integer position

col2 = row['col2']   # access via name

col3 = row[mytable.c.mycol] # access via Column object.
</pre>
<p>ResultProxy also contains a map of TypeEngine objects and will
invoke the appropriate <tt class="docutils literal"><span class="pre">result_processor()</span></tt> method before
returning columns, as well as the ExecutionContext corresponding
to the statement execution.  It provides several methods for which
to obtain information from the underlying ExecutionContext.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>context</i>)</b>
    <div class="docstring">
    <p>ResultProxy objects are constructed via the execute() method on SQLEngine.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close(<i>self</i>)</b>
    <div class="docstring">
    <p>Close this ResultProxy, and the underlying DB-API cursor corresponding to the execution.</p>
<p>If this ResultProxy was generated from an implicit execution,
the underlying Connection will also be closed (returns the
underlying DB-API connection to the connection pool.)</p>
<p>This method is also called automatically when all result rows
are exhausted.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def fetchall(<i>self</i>)</b>
    <div class="docstring">
    <p>Fetch all rows, just like DB-API <tt class="docutils literal"><span class="pre">cursor.fetchall()</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def fetchmany(<i>self</i>, <i>size=None</i>)</b>
    <div class="docstring">
    <p>Fetch many rows, just like DB-API <tt class="docutils literal"><span class="pre">cursor.fetchmany(size=cursor.arraysize)</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def fetchone(<i>self</i>)</b>
    <div class="docstring">
    <p>Fetch one row, just like DB-API <tt class="docutils literal"><span class="pre">cursor.fetchone()</span></tt>.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>keys = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_inserted_ids(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">last_inserted_ids()</span></tt> from the underlying ExecutionContext.</p>
<p>See ExecutionContext for details.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_inserted_params(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">last_inserted_params()</span></tt> from the underlying ExecutionContext.</p>
<p>See ExecutionContext for details.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def last_updated_params(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">last_updated_params()</span></tt> from the underlying ExecutionContext.</p>
<p>See ExecutionContext for details.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def lastrow_has_defaults(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">lastrow_has_defaults()</span></tt> from the underlying ExecutionContext.</p>
<p>See ExecutionContext for details.</p>

    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>lastrowid = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>out_parameters = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def postfetch_cols(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">postfetch_cols()</span></tt> from the underlying ExecutionContext.</p>
<p>See ExecutionContext for details.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def prefetch_cols(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>rowcount = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def scalar(<i>self</i>)</b>
    <div class="docstring">
    <p>Fetch the first column of the first row, and close the result set.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def supports_sane_multi_rowcount(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">supports_sane_multi_rowcount</span></tt> from the dialect.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def supports_sane_rowcount(<i>self</i>)</b>
    <div class="docstring">
    <p>Return <tt class="docutils literal"><span class="pre">supports_sane_rowcount</span></tt> from the dialect.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __iter__(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_RootTransaction"></a>
    
    <div class="sectionL3">

    <h3>class RootTransaction(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Transaction">Transaction</a>)</h3>
    
    
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">RootTransaction</span></tt>.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_RowProxy"></a>
    
    <div class="sectionL3">

    <h3>class RowProxy(object)</h3>
    
    
    <div class="darkcell"><p>Proxy a single cursor row for a parent ResultProxy.</p>
<p>Mostly follows &quot;ordered dictionary&quot; behavior, mapping result
values to the string-based column name, the integer position of
the result in the row, as well as Column instances which can be
mapped to the original Columns that produced this result set (for
results that correspond to constructed SQL expressions).</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>parent</i>, <i>row</i>)</b>
    <div class="docstring">
    <p>RowProxy objects are constructed by ResultProxy objects.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close(<i>self</i>)</b>
    <div class="docstring">
    <p>Close the parent ResultProxy.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def has_key(<i>self</i>, <i>key</i>)</b>
    <div class="docstring">
    <p>Return True if this RowProxy contains the given key.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def items(<i>self</i>)</b>
    <div class="docstring">
    <p>Return a list of tuples, each tuple containing a key/value pair.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def keys(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the list of keys as strings represented by this RowProxy.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def values(<i>self</i>)</b>
    <div class="docstring">
    <p>Return the values represented by this RowProxy as a list.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __contains__(<i>self</i>, <i>key</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __eq__(<i>self</i>, <i>other</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __getattr__(<i>self</i>, <i>name</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __getitem__(<i>self</i>, <i>key</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __iter__(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __len__(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __ne__(<i>self</i>, <i>other</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_SchemaIterator"></a>
    
    <div class="sectionL3">

    <h3>class SchemaIterator(<a href="sqlalchemy_schema.html#docstrings_sqlalchemy.schema_SchemaVisitor">SchemaVisitor</a>)</h3>
    
    
    <div class="darkcell"><p>A visitor that can gather text into a buffer and execute the contents of the buffer.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>connection</i>)</b>
    <div class="docstring">
    <p>Construct a new SchemaIterator.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def append(<i>self</i>, <i>s</i>)</b>
    <div class="docstring">
    <p>Append content to the SchemaIterator's query buffer.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def execute(<i>self</i>)</b>
    <div class="docstring">
    <p>Execute the contents of the SchemaIterator's buffer.</p>

    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_Transaction"></a>
    
    <div class="sectionL3">

    <h3>class Transaction(object)</h3>
    
    
    <div class="darkcell"><p>Represent a Transaction in progress.</p>
<p>The Transaction object is <strong>not</strong> threadsafe.</p>
</div>
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>connection</i>, <i>parent</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">Transaction</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def close(<i>self</i>)</b>
    <div class="docstring">
    <p>Close this transaction.</p>
<p>If this transaction is the base transaction in a begin/commit
nesting, the transaction will rollback().  Otherwise, the
method returns.</p>
<p>This is used to cancel a Transaction without affecting the scope of
an enclosing transaction.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def commit(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>connection = property()</b>
         <div class="docstring">
         <p>The Connection object referenced by this Transaction</p>

         </div> 
         </div>

                    
         <div class="darkcell">
         <A name=""></a>
         <b>is_active = property()</b>
         <div class="docstring">
         
         </div> 
         </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def rollback(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __enter__(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __exit__(<i>self</i>, <i>type</i>, <i>value</i>, <i>traceback</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



            
    

    
    
    <A name="docstrings_sqlalchemy.engine_TwoPhaseTransaction"></a>
    
    <div class="sectionL3">

    <h3>class TwoPhaseTransaction(<a href="sqlalchemy_engine.html#docstrings_sqlalchemy.engine_Transaction">Transaction</a>)</h3>
    
    
    

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def __init__(<i>self</i>, <i>connection</i>, <i>xid</i>)</b>
    <div class="docstring">
    <p>Construct a new <tt class="docutils literal"><span class="pre">TwoPhaseTransaction</span></tt>.</p>

    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def commit(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>

                    
    <div class="darkcell">
    
    <A name=""></a>
    <b>def prepare(<i>self</i>)</b>
    <div class="docstring">
    
    </div>
    </div>


    

            <a href="#top" class="totoc">back to section top</a>
    </div>



    

    </div>





    <div class="bottomnav">
        
    <div class="prevnext">
            Up: <a href="docstrings.html">API Documentation</a>


            
            Next: <a href="sqlalchemy_engine_default.html">module sqlalchemy.engine.default</a>
    </div>

    </div>








</body>
</html>






